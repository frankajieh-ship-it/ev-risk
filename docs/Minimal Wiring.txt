0) Folder layout (add these)
/data_v1.0/
  battery_degradation.json
  range_delta.csv
  recalls.csv
  owner_issue_clusters.json
  climate_zones.csv
  charger_density.csv
  assumptions.md

/lib/
  data.ts
  scoring.ts

/app/
  api/
    score/route.ts
    checkout/route.ts
  report/page.tsx
  page.tsx   (update to call /api/score + redirect to Stripe)

1) Data loaders (reads JSON/CSV from /data_v1.0)
lib/data.ts
import fs from "fs";
import path from "path";

const DATA_DIR = path.join(process.cwd(), "data_v1.0");

export function readJson<T>(filename: string): T {
  const p = path.join(DATA_DIR, filename);
  const raw = fs.readFileSync(p, "utf-8");
  return JSON.parse(raw) as T;
}

export function readCsv(filename: string): Array<Record<string, string>> {
  const p = path.join(DATA_DIR, filename);
  const raw = fs.readFileSync(p, "utf-8");
  const lines = raw.split(/\r?\n/).filter(Boolean);
  if (lines.length < 2) return [];

  const headers = lines[0].split(",").map((h) => h.trim());
  return lines.slice(1).map((line) => {
    const cols = line.split(",").map((c) => c.trim());
    const row: Record<string, string> = {};
    headers.forEach((h, i) => (row[h] = cols[i] ?? ""));
    return row;
  });
}

2) v1.0 scoring engine (simple, rules-first, uses your datasets)
lib/scoring.ts
import { readCsv, readJson } from "./data";

export type RiskLevel = "green" | "yellow" | "red";

export type ScoreInput = {
  vinOrModel: string;
  zip: string;
  dailyMiles: number;
  homeCharging: boolean;
  riskTolerance: "low" | "medium" | "high";
};

export type ReportResult = {
  level: RiskLevel;
  score: number; // 0â€“100 buy confidence (higher is better)
  verdict: string;
  reasons: string[];

  // Full report fields
  reportId: string;
  summaryVerdict: string;
  batteryRiskExplanation: string[];
  platformRecallRisk: string[];
  ownershipFit: string[];
  dealerQuestions: string[];
  walkAwayTriggers: string[];
};

type BatteryDegradation = Record<
  string,
  {
    base_degradation_per_year_pct: number;
    base_degradation_per_10k_miles_pct: number;
    heat_sensitivity_multiplier: number;
    cold_sensitivity_multiplier: number;
    notes: string;
  }
>;

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

function levelFromScore(score: number): RiskLevel {
  if (score >= 70) return "green";
  if (score >= 45) return "yellow";
  return "red";
}

function normalizeModelKey(vinOrModel: string) {
  return vinOrModel.trim();
}

/**
 * MVP v1: if VIN not decoded yet, treat vinOrModel as a lookup key.
 * Later: add VIN decode -> model/year/trim/chemistry mapping.
 */
export function scoreV1(input: ScoreInput): ReportResult {
  const battery = readJson<BatteryDegradation>("battery_degradation.json");
  const climateRows = readCsv("climate_zones.csv");
  const chargerRows = readCsv("charger_density.csv");
  const recallRows = readCsv("recalls.csv");
  const rangeRows = readCsv("range_delta.csv");
  const ownerClusters = readJson<any>("owner_issue_clusters.json");

  const modelKey = normalizeModelKey(input.vinOrModel);
  const zip = input.zip.trim();

  const climate = climateRows.find((r) => r.zip === zip);
  const heatIndex = climate ? Number(climate.heat_index || "1.0") : 1.0;
  const coldIndex = climate ? Number(climate.cold_index || "1.0") : 1.0;
  const climateStress = Math.max(heatIndex, coldIndex);

  const charger = chargerRows.find((r) => r.zip === zip);
  const chargersPer10k = charger ? Number(charger.chargers_per_10k_people || "0") : 0;
  const dcFastRatio = charger ? Number(charger.dc_fast_ratio || "0") : 0;

  // Range delta: find best match (exact model+year in v1 dataset; otherwise skip)
  const rangeMatch = rangeRows.find((r) => r.model === modelKey);
  const deltaPct = rangeMatch ? Number(rangeMatch.delta_pct || "0") : 0;

  // Recall density (platform risk proxy)
  const recallMatch = recallRows.find((r) => r.model === modelKey);
  const recallCount = recallMatch ? Number(recallMatch.recall_count || "0") : 0;
  const criticalRecalls = recallMatch ? Number(recallMatch.critical_recalls || "0") : 0;

  // Owner weak-signal clustering
  const cluster = ownerClusters?.[modelKey];
  const batteryRelatedFlags = cluster?.battery_related_flags ?? 0;
  const commonIssues: Array<{ issue: string; severity: string }> = cluster?.common_issues ?? [];

  // Chemistry assumption (v1): if unknown, default to NMC
  // Later: map model/year -> chemistry from dataset.
  const chemistry = (battery["LFP"] && /LFP/i.test(modelKey)) ? "LFP" : "NMC";
  const chem = battery[chemistry] ?? battery["NMC"];

  // --- Scoring (0â€“100 Buy Confidence) ---
  let score = 75;

  // Battery risk (climate + usage)
  // (Directional: higher daily miles & climate stress reduce confidence)
  if (input.dailyMiles >= 80) score -= 12;
  else if (input.dailyMiles >= 50) score -= 8;
  else if (input.dailyMiles >= 30) score -= 4;

  if (climateStress >= 1.25) score -= 10;
  else if (climateStress >= 1.10) score -= 5;

  if (batteryRelatedFlags >= 2) score -= 12;
  else if (batteryRelatedFlags === 1) score -= 6;

  // Platform / recall risk
  if (criticalRecalls >= 2) score -= 15;
  else if (criticalRecalls === 1) score -= 8;

  if (recallCount >= 5) score -= 10;
  else if (recallCount >= 3) score -= 6;

  // Ownership fit
  if (!input.homeCharging) {
    score -= 10;
    if (chargersPer10k > 0 && chargersPer10k < 10) score -= 12;
  }

  // If real-world range is commonly lower than EPA, reduce confidence if daily miles high
  if (deltaPct < -10 && input.dailyMiles >= 50) score -= 8;
  else if (deltaPct < -15) score -= 6;

  // Risk tolerance shaping
  if (input.riskTolerance === "low") score -= 6;
  if (input.riskTolerance === "high") score += 4;

  score = clamp(score, 5, 95);
  const level = levelFromScore(score);

  const verdict =
    level === "green"
      ? "This looks like a solid used-EV buy for your driving and charging setup."
      : level === "yellow"
        ? "This could be a good buy, but verify battery condition and a few platform risks first."
        : "High risk for your situationâ€”verify battery condition and platform history before committing.";

  const topReasons: string[] = [];
  if (!input.homeCharging) topReasons.push("No home charging increases dependence on local public charging reliability.");
  if (chargersPer10k > 0 && chargersPer10k < 10) topReasons.push("Local charger density is low for a home-charging-free setup.");
  if (climateStress >= 1.10) topReasons.push("Your climate increases range loss and accelerates battery wear over time.");
  if (criticalRecalls >= 1) topReasons.push("This model has meaningful recall historyâ€”confirm completion status before buying.");
  if (batteryRelatedFlags >= 1) topReasons.push("Owners report battery-related concernsâ€”verify battery health before purchase.");
  if (topReasons.length < 3) topReasons.push("Weâ€™ll validate range fit, recall status, and battery risk in the full report.");
  const reasons = topReasons.slice(0, 3);

  // --- Full Report copy blocks (plain English) ---
  const summaryVerdict = `${verdict} (Buy Confidence: ${score}/100, ${level.toUpperCase()})`;

  const batteryRiskExplanation = [
    `Chemistry assumption: ${chemistry} (${chem.notes}).`,
    `Climate stress factor applied: ${climateStress.toFixed(2)} (higher = more stress).`,
    `Directional degradation model: ~${chem.base_degradation_per_year_pct}%/year + ~${chem.base_degradation_per_10k_miles_pct}% per 10k miles (before climate multiplier).`,
    batteryRelatedFlags ? `Owner battery flags: ${batteryRelatedFlags} (higher = more caution).` : "No strong owner battery flags detected in v1 dataset."
  ];

  const platformRecallRisk = [
    `Recalls: ${recallCount} total; critical recalls: ${criticalRecalls}.`,
    criticalRecalls >= 1 ? "Action: ask for proof that critical recalls were completed (invoice/service record)." : "Action: still confirm recall status via seller/dealer.",
    commonIssues.length ? `Common owner issues reported: ${commonIssues.slice(0, 3).map(x => x.issue).join(", ")}.` : "No major owner issue clusters found in v1 dataset."
  ];

  const ownershipFit = [
    `Daily miles: ${input.dailyMiles} â€” higher daily use reduces buffer for weather range loss.`,
    input.homeCharging ? "Home charging: YES â€” lowers ownership friction and public-charger dependency." : "Home charging: NO â€” public charging availability and uptime matter much more.",
    chargersPer10k ? `Local charger density: ${chargersPer10k}/10k people; DC fast ratio: ${(dcFastRatio * 100).toFixed(0)}%.` : "Charger density unknown for ZIP in v1 dataset.",
    rangeMatch ? `Typical real-world range delta: ${deltaPct}% vs EPA (directional).` : "Real-world range delta not available for this model in v1 dataset."
  ];

  const dealerQuestions = [
    "Can you provide the most recent battery health / service report (or allow an inspection)?",
    "Have all recalls been completed? Show documentation.",
    "Has the vehicle had any battery pack replacement, module replacement, or thermal system work?",
    "Whatâ€™s the remaining warranty on battery and drivetrain (and is it transferable)?",
    "Can I test drive from 80%â†’40% SOC to observe range drop and charging behavior?"
  ];

  const walkAwayTriggers = [
    "Seller refuses any battery health verification or inspection.",
    "Critical recalls show â€˜incompleteâ€™ or documentation is missing.",
    "Range drop feels materially worse than expected for the mileage/climate.",
    "Unusual charging behavior (very slow DC fast charge at moderate SOC) without explanation.",
    "Multiple warning lights, cooling system errors, or repeated fault codes during test drive."
  ];

  // Stable reportId (simple): can be replaced later with DB id
  const reportId = `rep_${Date.now()}_${Math.random().toString(16).slice(2)}`;

  return {
    level,
    score,
    verdict,
    reasons,
    reportId,
    summaryVerdict,
    batteryRiskExplanation,
    platformRecallRisk,
    ownershipFit,
    dealerQuestions,
    walkAwayTriggers,
  };
}

3) Score API route (UI calls this instead of computeMvpResult)
app/api/score/route.ts
import { NextResponse } from "next/server";
import { scoreV1 } from "@/lib/scoring";

export async function POST(req: Request) {
  const body = await req.json();

  const vinOrModel = String(body.vinOrModel ?? "");
  const zip = String(body.zip ?? "");
  const dailyMiles = Number(body.dailyMiles ?? 0);
  const homeCharging = String(body.homeCharging ?? "yes") === "yes";
  const riskTolerance = (String(body.riskTolerance ?? "medium") as "low" | "medium" | "high");

  if (!vinOrModel.trim() || zip.trim().length < 3) {
    return NextResponse.json({ error: "Missing vinOrModel or zip" }, { status: 400 });
  }

  const result = scoreV1({ vinOrModel, zip, dailyMiles, homeCharging, riskTolerance });

  return NextResponse.json(result);
}

4) Paid Report web view (printable â†’ â€œSave as PDFâ€)

This is the paid deliverable (web view). Users can Print â†’ Save as PDF immediately (no PDF infrastructure needed).

app/report/page.tsx
"use client";

import React, { useEffect, useMemo, useState } from "react";

type RiskLevel = "green" | "yellow" | "red";

type ReportResult = {
  level: RiskLevel;
  score: number;
  reportId: string;

  summaryVerdict: string;
  batteryRiskExplanation: string[];
  platformRecallRisk: string[];
  ownershipFit: string[];
  dealerQuestions: string[];
  walkAwayTriggers: string[];
};

function levelEmoji(level: RiskLevel) {
  return level === "green" ? "ðŸŸ¢" : level === "yellow" ? "ðŸŸ¡" : "ðŸ”´";
}
function levelLabel(level: RiskLevel) {
  return level === "green" ? "Good Buy" : level === "yellow" ? "Proceed Carefully" : "High Risk";
}

export default function ReportPage() {
  const [data, setData] = useState<ReportResult | null>(null);
  const [err, setErr] = useState<string | null>(null);

  const params = useMemo(() => new URLSearchParams(window.location.search), []);
  const payloadStr = params.get("payload"); // base64 json

  useEffect(() => {
    try {
      if (!payloadStr) throw new Error("Missing payload");
      const json = JSON.parse(atob(payloadStr)) as ReportResult;
      setData(json);
    } catch (e: any) {
      setErr(e?.message ?? "Failed to load report");
    }
  }, [payloadStr]);

  if (err) {
    return (
      <main className="min-h-screen bg-white px-4 py-10">
        <div className="mx-auto max-w-3xl rounded-2xl border p-6">
          <div className="text-lg font-semibold">Report unavailable</div>
          <p className="mt-2 text-sm text-neutral-600">{err}</p>
        </div>
      </main>
    );
  }

  if (!data) {
    return (
      <main className="min-h-screen bg-white px-4 py-10">
        <div className="mx-auto max-w-3xl text-sm text-neutral-600">Loading reportâ€¦</div>
      </main>
    );
  }

  return (
    <main className="min-h-screen bg-white text-neutral-900">
      <div className="mx-auto max-w-3xl px-4 py-8">
        <div className="flex items-start justify-between gap-4">
          <div>
            <div className="text-xs text-neutral-500">EV-Riskâ„¢ Reliability Report</div>
            <h1 className="mt-1 text-2xl font-semibold">Pre-Purchase Buy Confidence</h1>
            <div className="mt-2 text-sm text-neutral-600">
              Report ID: <span className="font-mono">{data.reportId}</span>
            </div>
          </div>

          <div className="text-right">
            <div className="text-4xl" aria-label={levelLabel(data.level)}>{levelEmoji(data.level)}</div>
            <div className="text-sm font-semibold">{levelLabel(data.level)}</div>
            <div className="text-xs text-neutral-600">Score: {data.score}/100</div>
            <button
              onClick={() => window.print()}
              className="mt-3 rounded-xl border px-3 py-2 text-sm font-medium hover:bg-neutral-50"
            >
              Print / Save as PDF
            </button>
          </div>
        </div>

        {/* Section: Summary verdict */}
        <section className="mt-8 rounded-2xl border p-5">
          <h2 className="text-sm font-semibold">Summary verdict</h2>
          <p className="mt-2 text-sm text-neutral-800">{data.summaryVerdict}</p>
        </section>

        {/* Section: Battery risk explanation */}
        <section className="mt-5 rounded-2xl border p-5">
          <h2 className="text-sm font-semibold">Battery risk explanation</h2>
          <ul className="mt-2 list-disc pl-5 text-sm text-neutral-800 space-y-1">
            {data.batteryRiskExplanation.map((x, i) => <li key={i}>{x}</li>)}
          </ul>
        </section>

        {/* Section: Platform & recall risk */}
        <section className="mt-5 rounded-2xl border p-5">
          <h2 className="text-sm font-semibold">Platform &amp; recall risk</h2>
          <ul className="mt-2 list-disc pl-5 text-sm text-neutral-800 space-y-1">
            {data.platformRecallRisk.map((x, i) => <li key={i}>{x}</li>)}
          </ul>
        </section>

        {/* Section: Ownership fit analysis */}
        <section className="mt-5 rounded-2xl border p-5">
          <h2 className="text-sm font-semibold">Ownership fit analysis</h2>
          <ul className="mt-2 list-disc pl-5 text-sm text-neutral-800 space-y-1">
            {data.ownershipFit.map((x, i) => <li key={i}>{x}</li>)}
          </ul>
        </section>

        {/* Section: What to ask the dealer */}
        <section className="mt-5 rounded-2xl border p-5">
          <h2 className="text-sm font-semibold">What to ask the dealer</h2>
          <ul className="mt-2 list-disc pl-5 text-sm text-neutral-800 space-y-1">
            {data.dealerQuestions.map((x, i) => <li key={i}>{x}</li>)}
          </ul>
        </section>

        {/* Section: When to walk away */}
        <section className="mt-5 rounded-2xl border p-5">
          <h2 className="text-sm font-semibold">When to walk away</h2>
          <ul className="mt-2 list-disc pl-5 text-sm text-neutral-800 space-y-1">
            {data.walkAwayTriggers.map((x, i) => <li key={i}>{x}</li>)}
          </ul>
        </section>

        <p className="mt-6 text-xs text-neutral-500">
          Disclaimer: This report provides a directional risk estimate, not a guarantee of vehicle condition.
        </p>
      </div>

      {/* Print styling */}
      <style jsx global>{`
        @media print {
          button { display: none !important; }
          a { text-decoration: none; color: inherit; }
          .border { border-color: #ddd !important; }
        }
      `}</style>
    </main>
  );
}

5) Stripe Checkout redirect (Phase 3 minimal)

This creates a Stripe Checkout Session and returns a URL you redirect to.

app/api/checkout/route.ts
import { NextResponse } from "next/server";
import Stripe from "stripe";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {
  apiVersion: "2025-01-27.acacia", // if this errors in your env, change to your installed Stripe version
});

export async function POST(req: Request) {
  const body = await req.json();

  // We pass the full report payload through success_url so the report can render immediately after payment.
  // In production: store the report server-side (DB) and pass only reportId.
  const payload = String(body.payload ?? "");
  if (!payload) return NextResponse.json({ error: "Missing payload" }, { status: 400 });

  const origin = req.headers.get("origin") ?? "http://localhost:3000";

  const session = await stripe.checkout.sessions.create({
    mode: "payment",
    line_items: [
      {
        price_data: {
          currency: "usd",
          unit_amount: 1500,
          product_data: {
            name: "EV-Riskâ„¢ Reliability Report + Negotiation Checklist",
          },
        },
        quantity: 1,
      },
    ],
    success_url: `${origin}/report?payload=${encodeURIComponent(payload)}`,
    cancel_url: `${origin}/?canceled=1`,
  });

  return NextResponse.json({ url: session.url });
}


Env var required:

STRIPE_SECRET_KEY=sk_live_...


If the Stripe API version string causes an error in your setup, change it to whatever your installed Stripe package expects (or omit apiVersion).

6) Update your MVP UI to use real scoring + Stripe redirect

Update your existing app/page.tsx like this:

Replace local compute + CTA

On submit: POST /api/score

On CTA: POST /api/checkout with payload = base64(JSON.stringify(fullReport))

Here are the minimal code changes (drop-in functions + replacements):

// Add this helper near top
function toB64Json(obj: any) {
  return btoa(JSON.stringify(obj));
}

// In onSubmit, replace computeMvpResult with API call:
async function onSubmit(e: React.FormEvent) {
  e.preventDefault();

  const res = await fetch("/api/score", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(form),
  });

  if (!res.ok) {
    alert("Failed to score. Check inputs and data files.");
    return;
  }

  const r = await res.json();
  setResult(r);
  setSubmitted(true);

  setTimeout(() => {
    document.getElementById("result")?.scrollIntoView({ behavior: "smooth", block: "start" });
  }, 50);
}

// Replace CTA onClick handler:
async function startCheckout() {
  if (!result) return;

  const payload = toB64Json(result);

  const res = await fetch("/api/checkout", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ payload }),
  });

  const data = await res.json();
  if (!data?.url) {
    alert("Checkout failed. Check Stripe env var.");
    return;
  }

  window.location.href = data.url;
}


Then change the CTA anchor to:

<button
  onClick={startCheckout}
  className="rounded-xl bg-neutral-900 text-white px-4 py-2 text-sm font-semibold"
>
  Unlock full report + negotiation checklist ($15)
</button>

MVP note (important, but keeps you moving)

Right now the report payload is passed through the URL after payment (fastest path).
Production upgrade (later): store the report server-side (DB) and pass only a reportId to /report/[id].